<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Bracket Algebra · BracketAlgebras.jl</title><meta name="title" content="The Bracket Algebra · BracketAlgebras.jl"/><meta property="og:title" content="The Bracket Algebra · BracketAlgebras.jl"/><meta property="twitter:title" content="The Bracket Algebra · BracketAlgebras.jl"/><meta name="description" content="Documentation for BracketAlgebras.jl."/><meta property="og:description" content="Documentation for BracketAlgebras.jl."/><meta property="twitter:description" content="Documentation for BracketAlgebras.jl."/><meta property="og:url" content="https://Saschobolt.github.io/BracketAlgebras.jl/bracket_algebra/"/><meta property="twitter:url" content="https://Saschobolt.github.io/BracketAlgebras.jl/bracket_algebra/"/><link rel="canonical" href="https://Saschobolt.github.io/BracketAlgebras.jl/bracket_algebra/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BracketAlgebras.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>The Bracket Algebra</a><ul class="internal"><li><a class="tocitem" href="#Basic-bracket-algebra-functionality"><span>Basic bracket algebra functionality</span></a></li><li class="toplevel"><a class="tocitem" href="#Straightening"><span>Straightening</span></a></li><li><a class="tocitem" href="#Straightening-syziges"><span>Straightening syziges</span></a></li><li><a class="tocitem" href="#Tabloids"><span>Tabloids</span></a></li><li><a class="tocitem" href="#The-straightening-algorithm"><span>The straightening algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Atomic-extensors"><span>Atomic extensors</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Bracket Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Bracket Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Saschobolt/BracketAlgebras.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/master/docs/src/bracket_algebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Bracket-Algebra"><a class="docs-heading-anchor" href="#The-Bracket-Algebra">The Bracket Algebra</a><a id="The-Bracket-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#The-Bracket-Algebra" title="Permalink"></a></h1><p>Let <span>$\{x_1, \dots, x_n\} \subset P^{d}$</span> be <span>$n$</span> points in projective space. The algebra generated by the <span>$d+1 \times d+1$</span>-minors of the matrix</p><p class="math-container">\[X = \begin{pmatrix} x_{1,1} &amp; \dots &amp; x_{1,d} &amp; 1 \\ &amp; \vdots &amp; \\ x_{n,1} &amp; \dots &amp; x_{n,d} &amp; 1  \end{pmatrix}\]</p><p>is called the bracket algebra <span>$\mathcal{B}_{n,d}$</span> Let <span>$\Lambda \coloneqq \Lambda(n,d+1) \coloneqq \{[\lambda_1, \dots, \lambda_{d+1}] \mid 1\leq \lambda_1 &lt; \dots &lt; \lambda_{d+1} \leq n\}$</span> and set <span>$[\lambda_{\pi(1)}, \dots \lambda_{\pi(d)}] = \mathrm{sgn}(\pi)[\lambda_1, \dots, \lambda_d]$</span> in <span>$\mathbb{C}(\Lambda)$</span>. Then </p><p class="math-container">\[\mathbb{C}[\Lambda] / I \to \mathcal{B}_{n,d}, [\lambda_1, \dots, \lambda_{d+1}] \mapsto 
\det \begin{pmatrix} x_{\lambda_1, 1} &amp; \dots &amp; x_{\lambda_1, d} &amp; 1 \\
&amp; \vdots &amp; \\
x_{\lambda_{d+1}, 1} &amp; \dots &amp; x_{\lambda_{d+1}, d} &amp; 1 \end{pmatrix}\]</p><p>defines an isomorphism, where <span>$I$</span> is the ideal generated by the so called Plücker relations &lt;!– Todo –&gt; We identify the elements of the bracket algebra with its corresponding preimage in <span>$\mathbb{C}[\Lambda]/I$</span>. We define a monomial ordering on the elements of <span>$\mathbb{C}[\Lambda]$</span>. For <span>$[\lambda] = [\lambda_1, \dots, \lambda_{d+1}], \mu = [\mu_1, \dots, \mu_{d+1}] \in \Lambda$</span> we set <span>$[\lambda] \leq [\mu]$</span> if and only if for some <span>$1\leq m \leq d+1$</span> we have <span>$\lambda_i = \mu_i$</span> for all <span>$1\leq i \leq m$</span> and <span>$\lambda_{m+1} \leq \mu_{m+1}$</span>, i.e. <span>$[\lambda]$</span> is smaller in the first entry <span>$[\lambda]$</span> and <span>$[\mu]$</span> differ. The degree reverse lexicographic ordering extending this ordering of the variables is called the <em>tableaux ordering</em>.</p><ul><li><a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebras.BracketAlgebra</code></a></li><li><a href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebras.BracketAlgebraElem</code></a></li><li><a href="#BracketAlgebras.Tabloid"><code>BracketAlgebras.Tabloid</code></a></li><li><a href="#BracketAlgebras.atomic_extensors"><code>BracketAlgebras.atomic_extensors</code></a></li><li><a href="#BracketAlgebras.d"><code>BracketAlgebras.d</code></a></li><li><a href="#BracketAlgebras.is_standard"><code>BracketAlgebras.is_standard</code></a></li><li><a href="#BracketAlgebras.n"><code>BracketAlgebras.n</code></a></li><li><a href="#BracketAlgebras.point_labels"><code>BracketAlgebras.point_labels</code></a></li><li><a href="#BracketAlgebras.point_labels!"><code>BracketAlgebras.point_labels!</code></a></li><li><a href="#BracketAlgebras.point_ordering"><code>BracketAlgebras.point_ordering</code></a></li><li><a href="#BracketAlgebras.point_ordering!"><code>BracketAlgebras.point_ordering!</code></a></li><li><a href="#BracketAlgebras.standard_violation"><code>BracketAlgebras.standard_violation</code></a></li><li><a href="#BracketAlgebras.straighten"><code>BracketAlgebras.straighten</code></a></li><li><a href="#BracketAlgebras.straightening_sizyge"><code>BracketAlgebras.straightening_sizyge</code></a></li></ul><h2 id="Basic-bracket-algebra-functionality"><a class="docs-heading-anchor" href="#Basic-bracket-algebra-functionality">Basic bracket algebra functionality</a><a id="Basic-bracket-algebra-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-bracket-algebra-functionality" title="Permalink"></a></h2><p>This package implements bracket algebras using the ring interface of the Julia package <a href="https://github.com/Nemocas/AbstractAlgebra.jl">AbstractAlgebra.jl</a>. As is usual for AbstractAlgebra rings, a bracket algebra is an object of type <a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebra</code></a> and the elements of a bracket algebra are objects of type <a href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebraElem</code></a>.</p><h3 id="Constructing-Bracket-Algebras"><a class="docs-heading-anchor" href="#Constructing-Bracket-Algebras">Constructing Bracket Algebras</a><a id="Constructing-Bracket-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-Bracket-Algebras" title="Permalink"></a></h3><p>Bracket algebras in this package are <a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebra</code></a> objects.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.BracketAlgebra" href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebras.BracketAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BracketAlgebra{T&lt;:RingElement} &lt;: AbstractBracketAlgebra{T}</code></pre><p>Bracket algebra with coefficients of type <code>T</code>.</p><p><strong>Fields</strong></p><ul><li><code>d::Int</code>: dimension of the underlying projective space P^<code>d</code></li><li><code>n::Int</code>: number of points considered</li><li><code>R::MPolyRing{T}</code>: AbstractAlgebra multivariate polynomial ring representing the elements of the bracket algebra (for internal use)</li><li><code>point_ordering::Vector{Int}</code>: ordering of the <code>n</code> point indices, that induces the tableaux order. <code>point_ordering[1] &lt; point_ordering[2] &lt; ... &lt; point_ordering[n]</code>. </li><li><code>variables::Bijection{Vector{Int},&lt;:MPolyRingElem{T}}</code>: bijection from brackets to the corresponding monomials in the polynomial ring <code>R</code></li><li><code>point_labels::Vector</code>: point labels for each point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L29-L41">source</a></section></article><p>To construct the bracket algebra <span>$\mathcal{B}_{6,3}$</span>, you can call</p><pre><code class="language-julia-repl hljs">julia&gt; BracketAlgebra(6,3)
Bracket algebra over P^3 on 6 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 and coefficient ring Integers.</code></pre><p>The standard labels for the <code>n</code> points is <code>1:n</code>. You can give different labels to the points by calling</p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];

julia&gt; BracketAlgebra(6, 3, point_labels=labels)
Bracket algebra over P^3 on 6 points with point ordering a &lt; b &lt; c &lt; d &lt; e &lt; f and coefficient ring Integers.</code></pre><p>Note that if the point labels are integers, they are always expected to be equal to <code>1:n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; BracketAlgebra(6,3,point_labels=[2,1,3,4,5,6])
ERROR: When point_labels is a Vector of Integers, it must equal collect(1:n)</code></pre><p>You can also construct bracket algebras with different orderings of the points. This translates to changing the ordering in the elements of <span>$\Lambda$</span> above.</p><pre><code class="language-julia-repl hljs">julia&gt; labels = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];

julia&gt; BracketAlgebra(6, 3, point_labels=labels)
Bracket algebra over P^3 on 6 points with point ordering a &lt; b &lt; c &lt; d &lt; e &lt; f and coefficient ring Integers.

julia&gt; BracketAlgebra(6, 3, [2,1,3,4,5,6], point_labels=labels)
Bracket algebra over P^3 on 6 points with point ordering b &lt; a &lt; c &lt; d &lt; e &lt; f and coefficient ring Integers.</code></pre><p>To access the contents of the fields of a <a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebra</code></a> the following access functions are provided</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.n" href="#BracketAlgebras.n"><code>BracketAlgebras.n</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n(B::BracketAlgebra)</code></pre><p>Return the number of points considered in the bracket algebra <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; n(BracketAlgebra(6,3))
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.d" href="#BracketAlgebras.d"><code>BracketAlgebras.d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d(B::BracketAlgebra)</code></pre><p>Return the dimension of the projective space P^<code>d</code> underlying the bracket algebra <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d(BracketAlgebra(6,3))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L174-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.point_ordering" href="#BracketAlgebras.point_ordering"><code>BracketAlgebras.point_ordering</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_ordering(B::BracketAlgebra)</code></pre><p>Return the ordering of the n points in the bracket algebra <code>B</code>, that induces the tableaux order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; point_ordering(BracketAlgebra(6,3,[2,1,3,4,5,6]))
6-element Vector{Int64}:
 2
 1
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L198-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.point_labels" href="#BracketAlgebras.point_labels"><code>BracketAlgebras.point_labels</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_labels(B::BracketAlgebra)</code></pre><p>Return the point labels of the bracket algebra <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L133-L137">source</a></section></article><p>To change the point ordering of an existing bracket algebra call</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.point_ordering!" href="#BracketAlgebras.point_ordering!"><code>BracketAlgebras.point_ordering!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_ordering!(B::BracketAlgebra, point_ordering::AbstractVector{&lt;:Integer}=collect(1:B.n))</code></pre><p>Update the point ordering of the bracket algebra <code>B</code> to <code>point_ordering</code> and return the updated bracket algebra.</p><p>Warning: changing the point ordering will not change the representation of already generated elements of <code>B</code>, which leads to wrong results when working with these elements. It is recommended to create a new bracket algebra with the desired point ordering instead. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; point_ordering!(BracketAlgebra(6,3), [6,5,4,3,2,1])
Bracket algebra over P^3 on 6 points with point ordering 6 &lt; 5 &lt; 4 &lt; 3 &lt; 2 &lt; 1 and coefficient ring Integers.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L217-L229">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Changing the point ordering of an existing <a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebra</code></a> will not update the point ordering in the internal representation of the already constructed <a href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebraElem</code></a>, even though they will have the updated bracket algebra as a parent object.</p></div></div><p>The generators of a bracket algebra, i.e. the brackets in the bracket algebra, can be computed by <code>AbstractAlgebra.gens</code>. </p><pre><code class="language-julia-repl hljs">julia&gt; gens(BracketAlgebra(4,2))
4-element Vector{BracketAlgebraElem{BigInt}}:
 [2, 3, 4]
 [1, 3, 4]
 [1, 2, 4]
 [1, 2, 3]

julia&gt; gens(BracketAlgebra(4,2,[2,1,3,4]))
4-element Vector{BracketAlgebraElem{BigInt}}:
 [1, 3, 4]
 [2, 3, 4]
 [2, 1, 4]
 [2, 1, 3]</code></pre><p>To change the point labels of an existin bracket algebra call</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.point_labels!" href="#BracketAlgebras.point_labels!"><code>BracketAlgebras.point_labels!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_labels!(B::BracketAlgebra, new_labels::AbstractVector)</code></pre><p>Update the point labels of the bracket algebra <code>B</code> and return the resulting bracket algebra. If <code>new_labels</code> is a vector of integers, it is expected to be equal to <code>collect(1:n(B))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; point_labels!(BracketAlgebra(6,3), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;])
Bracket algebra over P^3 on 6 points with point ordering a &lt; b &lt; c &lt; d &lt; e &lt; f and coefficient ring Integers.</code></pre><pre><code class="language-julia-repl hljs">julia&gt; point_labels!(BracketAlgebra(6,3), [2,1,3,4,5,&quot;a&quot;])
Bracket algebra over P^3 on 6 points with point ordering 2 &lt; 1 &lt; 3 &lt; 4 &lt; 5 &lt; a and coefficient ring Integers.</code></pre><pre><code class="language-julia-repl hljs">julia&gt; point_labels!(BracketAlgebra(6,3), [2,1,3,4,5,6])
ERROR: When point_labels is a Vector of Integers, it must equal collect(1:n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L140-L160">source</a></section></article><p>The coefficient ring of the bracket algebra can be accessed via <code>AbstractAlgebra.base_ring</code></p><pre><code class="nohighlight hljs">julia&gt; base_ring(BracketAlgebra(4,2,[1,2,3,4],Rational{BigInt}))
Rationals

julia&gt; base_ring(BracketAlgebra(4,2,[1,2,3,4],BigInt))
Integers

julia&gt; base_ring(BracketAlgebra(4,2,[1,2,3,4],AbstractAlgebra.GF(13)))
Finite field F_13</code></pre><h3 id="Constructing-bracket-algebra-elements"><a class="docs-heading-anchor" href="#Constructing-bracket-algebra-elements">Constructing bracket algebra elements</a><a id="Constructing-bracket-algebra-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-bracket-algebra-elements" title="Permalink"></a></h3><p>The elements of a bracket algebra are <a href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebraElem</code></a> objects.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.BracketAlgebraElem" href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebras.BracketAlgebraElem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BracketAlgebraElem{T&lt;:Union{RingElem,Number}} &lt;: AbstractBracketAlgebraElem{T}</code></pre><p>Element type for <a href="#BracketAlgebras.BracketAlgebra"><code>BracketAlgebra</code></a> with coefficients of type <code>T</code>.</p><p><strong>Fields</strong></p><ul><li><code>parent::BracketAlgebra{T}</code>: parent object of the bracket algebra element.</li><li><code>polynomial::MPolyRingElem{T}</code>: polynomial in <code>parent.R</code> that represents the element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/BracketAlgebras.jl#L256-L264">source</a></section></article><p>The easiest way to construct bracket algebra elements is to first construct a bracket algebra <code>B</code> and then constructing the elements with <code>B(bracket)</code>, where bracket is a vector of point labels of length <code>d(B)+1</code>, as in the following example</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2, point_labels = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])
Bracket algebra over P^2 on 4 points with point ordering a &lt; b &lt; c &lt; d and coefficient ring Integers.

julia&gt; B([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>You can also generate a bracket algebra element in the same way by providing the indices of the labels.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2, point_labels = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])
Bracket algebra over P^2 on 4 points with point ordering a &lt; b &lt; c &lt; d and coefficient ring Integers.

julia&gt; B([1,2,3])
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>Brackets are alternating, therefore</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2, point_labels = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])
Bracket algebra over P^2 on 4 points with point ordering a &lt; b &lt; c &lt; d and coefficient ring Integers.

julia&gt; B([2,1,3])
 - [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

julia&gt; B([2,2,3])
0</code></pre><p>Elements <code>a</code> of the coefficient ring of a bracket algebra <code>B</code> can be coerced into the bracket algebra by calling <code>B(a)</code>. <code>B()</code> will construct the zero element of <code>B</code>. <code>zero(B)</code> and <code>one(B)</code> are also implemented to return the zero and one element of <code>B</code> as well as methods for functions <code>iszero(b)</code> and <code>isone(b)</code> to check whether a bracket algebra element is the zero or one element.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; B(1)
1

julia&gt; typeof(B(1))
BracketAlgebraElem{BigInt}

julia&gt; B()
0

julia&gt; zero(B)
0

julia&gt; one(B)
1

julia&gt; isone(one(B))
true

julia&gt; iszero(zero(B))
true</code></pre><p>Brackets can be added, multiplied and multiplied with elements of the base ring to form more complex bracket expressions. Internally they are stored according to the tableaux ordering, which is also why it is not recommended to change the point ordering of a bracket algebra, which already has existing elements (see <a href="#BracketAlgebras.point_ordering!"><code>point_ordering!</code></a>).</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; B([1,2,3])*B([2,3,4]) + 2*B([1,2,4])^2 - B([2,3,4])*B([1,3,4])
 - [2, 3, 4][1, 3, 4] + 2[1, 2, 4]^2 + [2, 3, 4][1, 2, 3]</code></pre><p>It is also possible to construct bracket algebra expressions by providing a vector of coefficients and a vector of exponent vectors of an expression.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; gens(B)
4-element Vector{BracketAlgebraElem{BigInt}}:
 [2, 3, 4]
 [1, 3, 4]
 [1, 2, 4]
 [1, 2, 3]

julia&gt; B([1,-2], [[1,2,3,4], [1,0,0,1]])
[2, 3, 4][1, 3, 4]^2[1, 2, 4]^3[1, 2, 3]^4 - 2[2, 3, 4][1, 2, 3]</code></pre><p>The bracket algebra that a <a href="#BracketAlgebras.BracketAlgebraElem"><code>BracketAlgebraElem</code></a> object <code>b</code> is an element of can be accessed via <code>parent(b)</code></p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4, 2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; b = B([1,2,3])
[1, 2, 3]

julia&gt; parent(b) === B
true</code></pre><h3 id="Arithmetic-operations-for-bracket-algebra-elements"><a class="docs-heading-anchor" href="#Arithmetic-operations-for-bracket-algebra-elements">Arithmetic operations for bracket algebra elements</a><a id="Arithmetic-operations-for-bracket-algebra-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operations-for-bracket-algebra-elements" title="Permalink"></a></h3><p>For bracket algebra elements the following arithmetic operations are implemented:</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4,2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; b1 = B([1,2,3]) * B([1,2,4]) + B([2,3,4])
[1, 2, 4][1, 2, 3] + [2, 3, 4]

julia&gt; b2 = B([1,2,3]) * B([2,3,4])
[2, 3, 4][1, 2, 3]

julia&gt; 2*b1 # multiplication with integers
2[1, 2, 4][1, 2, 3] + 2[2, 3, 4]

julia&gt; -b1 # additive inverse
 - [1, 2, 4][1, 2, 3] - [2, 3, 4]

julia&gt; b1^3 # raising bracket algebra expressions to an integer power
[1, 2, 4]^3[1, 2, 3]^3 + 3[2, 3, 4][1, 2, 4]^2[1, 2, 3]^2 + 3[2, 3, 4]^2[1, 2, 4][1, 2, 3] + [2, 3, 4]^3

julia&gt; b1+b2 # addition of bracket algebra elements
[2, 3, 4][1, 2, 3] + [1, 2, 4][1, 2, 3] + [2, 3, 4]

julia&gt; b1-b2 # subtraction of bracket algebra elements
 - [2, 3, 4][1, 2, 3] + [1, 2, 4][1, 2, 3] + [2, 3, 4]

julia&gt; b1*b2 # multiplication of bracket algebra elements
[2, 3, 4][1, 2, 4][1, 2, 3]^2 + [2, 3, 4]^2[1, 2, 3]</code></pre><p>We can also compare representatives of bracket algebra monomials with regards to the tableuaux ordering.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4,2)
Bracket algebra over P^2 on 4 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 and coefficient ring Integers.

julia&gt; b1 = B([1,2,3]) * B([2,3,4])
[2, 3, 4][1, 2, 3]

julia&gt; b2 = B([1,2,3]) * B([1,2,4])
[1, 2, 4][1, 2, 3]

julia&gt; b3 = B([2,3,4])
[2, 3, 4]

julia&gt; b1 &lt; b2
false

julia&gt; b1 &gt; b2
true

julia&gt; b1 &gt; b3
true</code></pre><h3 id="Bracket-algebra-elements-as-polynomials"><a class="docs-heading-anchor" href="#Bracket-algebra-elements-as-polynomials">Bracket algebra elements as polynomials</a><a id="Bracket-algebra-elements-as-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Bracket-algebra-elements-as-polynomials" title="Permalink"></a></h3><p>We can query information about the chosen representative in <span>$\mathbb{C}[\Lambda]$</span> of a bracket algebra element as a polynomial. These are implemented as extensions of functions in the <code>AbstractAlgebra.jl</code> package.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4,2);

julia&gt; b = B([1,2,3]) * B([2,3,4]) + 2*B([1,3,4]) * B([1,2,3])
[2, 3, 4][1, 2, 3] + 2[1, 3, 4][1, 2, 3]

julia&gt; length(b) # number of terms of b
2

julia&gt; degrees(b) # degree of b in gens(parent(b))
4-element Vector{Int64}:
 1
 1
 0
 1

julia&gt; total_degree(b) # tatal degree of b
2

julia&gt; collect(coefficients(b)) # coefficients of the terms of b in tableaux ordering
2-element Vector{BigInt}:
 1
 2

julia&gt; collect(monomials(b)) # monomials making up the terms of b in tableaux ordering
2-element Vector{BracketAlgebraElem{BigInt}}:
 [2, 3, 4][1, 2, 3]
 [1, 3, 4][1, 2, 3]

julia&gt; collect(terms(b)) # terms of b in tableaux ordering
2-element Vector{BracketAlgebraElem{BigInt}}:
 [2, 3, 4][1, 2, 3]
 2[1, 3, 4][1, 2, 3]

julia&gt; collect(exponent_vectors(b)) # exponent vectors of terms of b in tableaux ordering
2-element Vector{Vector{Int64}}:
 [1, 0, 0, 1]
 [0, 1, 0, 1]

julia&gt; coeff(b, 2) # coefficient of second term
2

julia&gt; coeff(b, [0,1,0,1]) # coefficient of the term with exponent vector [0,1,0,1]
2

julia&gt; monomial(b, 2) # monomial of second term
[1, 3, 4][1, 2, 3]

julia&gt; exponent_vector(b, 2) # exponent vector of second term
4-element Vector{Int64}:
 0
 1
 0
 1

julia&gt; term(b, 2) # second term
2[1, 3, 4][1, 2, 3]

julia&gt; leading_term(b) # leading term of b
[2, 3, 4][1, 2, 3]

julia&gt; leading_monomial(b) # leading monomial of b
[2, 3, 4][1, 2, 3]

julia&gt; leading_coefficient(b) # leading coefficient of b
1</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that these notions are not well defined for bracket algebra expressions. They are calculated for the chosen representative in <span>$\mathbb{C}[\Lambda]$</span>.</p></div></div><p>You can evaluate a bracket expression <code>b</code> of a bracket algebra <code>B</code> at a coordinization of the points in homogeneous coordinates. For that provide the coordinization as a <span>$d\times n$</span> matrix, where the columns correspond to the point coordinates and call <code>evaluate(b, coordinization)</code></p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(4,2);

julia&gt; b = B([2,3,4]) * B([1,2,4])
[2, 3, 4][1, 2, 4]

julia&gt; coordinization = [0 1 0 1; 0 0 1 1]
2×4 Matrix{Int64}:
 0  1  0  1
 0  0  1  1

julia&gt; evaluate(b, coordinization)
-1.0

julia&gt; x = hcat(transpose(coordinization), ones(4,1)) # matrix X as in introduction
4×3 Matrix{Float64}:
 0.0  0.0  1.0
 1.0  0.0  1.0
 0.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; det(x[[2,3,4], :]) * det(x[[1,2,4], :])
-1.0</code></pre><h1 id="Straightening"><a class="docs-heading-anchor" href="#Straightening">Straightening</a><a id="Straightening-1"></a><a class="docs-heading-anchor-permalink" href="#Straightening" title="Permalink"></a></h1><p>We want to define a normal form for bracket algebra elements. This is achieved by the isomorphism <span>$\mathcal{B}_{n,d} \cong \mathbb{C}[\Lambda]/I$</span>. </p><h2 id="Straightening-syziges"><a class="docs-heading-anchor" href="#Straightening-syziges">Straightening syziges</a><a id="Straightening-syziges-1"></a><a class="docs-heading-anchor-permalink" href="#Straightening-syziges" title="Permalink"></a></h2><p>Let <span>$1\leq s \leq d+1$</span>, <span>$\alpha \in \Lambda(n, s-1)$</span>, <span>$\beta \in \Lambda(n, d+2)$</span> and <span>$\gamma \in \Lambda(n, d + 1 - s)$</span>. For <span>$\tau = \{\tau_1 &lt; \dots &lt;\tau_s\}\subset \{1, \dots, d+2\}$</span> let <span>$\tau^\ast = \{1, \dots, d+2\} \setminus \tau = \{\tau^\ast_1 &lt; \dots &lt; \tau^\ast_{d+2-s}}$</span> and</p><p class="math-container">\[\mathrm{sgn}(\tau*, \tau) = \mathrm{sgn} \begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; \dots &amp; d+2-s &amp; d+2-s+1 &amp; \dots &amp; d+2 \\
\tau^\ast_1 &amp; \tau^\ast_2 &amp; \tau^\ast_3 &amp; \dots &amp; \tau^\ast_{d+2-s} &amp; \tau_1 &amp; \dots &amp; \tau_s 
\end{pmatrix}.\]</p><p>We define the straightening syzige </p><p class="math-container">\[[[\alpha, \dot{\beta}, \gamma]] = \sum_{\tau \in \mathrm{Pot}_s(\underline{d+2})} \mathrm{sgn}(\tau*, \tau) [\alpha_1, \dots, \alpha_{s-1}, \beta_{\tau^\ast_1}, \dots, \beta_{\tau^\ast_{d+2-s}}][\beta_{\tau_1}, \dots, \beta_{\tau_s}, \gamma_1, \dots, \gamma_{d+1-s}] \in \mathbb{C}(\Lambda).\]</p><p>The straightening syzige of <code>\alpha</code>, <code>\beta</code> and <code>\gamma</code> in a bracket algebra <code>B</code> can be constructed using the function <code>straightening_syzige</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.straightening_sizyge" href="#BracketAlgebras.straightening_sizyge"><code>BracketAlgebras.straightening_sizyge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">straightening_sizyge(α::Vector{&lt;:Integer}, β::Vector{&lt;:Integer}, γ::Vector{&lt;:Integer}, B::BracketAlgebra)</code></pre><p>Return the straightening_sizyge corresponding to <code>α</code>, <code>β</code>, <code>γ</code> as an element of the bracket algebra <code>B</code>. The lenghts of the vectors have to fulfill <code>length(β)==d(B)+2</code> and <code>length(γ)==d(B)-length(α)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(6,2)
Bracket algebra over P^2 on 6 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 and coefficient ring Integers.

julia&gt; α = [1]
1-element Vector{Int64}:
 1

julia&gt; β = [5,6,2,3]
4-element Vector{Int64}:
 5
 6
 2
 3

julia&gt; γ = [4]
1-element Vector{Int64}:
 4

julia&gt; straightening_sizyge(α, β, γ, B)
[2, 3, 4][1, 5, 6] + [2, 4, 5][1, 3, 6] - [2, 4, 6][1, 3, 5] - [3, 4, 5][1, 2, 6] + [3, 4, 6][1, 2, 5] + [4, 5, 6][1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L129-L158">source</a></section></article><h2 id="Tabloids"><a class="docs-heading-anchor" href="#Tabloids">Tabloids</a><a id="Tabloids-1"></a><a class="docs-heading-anchor-permalink" href="#Tabloids" title="Permalink"></a></h2><p>Further we need to introduce the notions of tabloids. Let <span>$[\lambda_1]\dots[lambda_k] \in \mathbb{C}[\Lambda]$</span> be a monomial, such that <span>$[\lambda_1]\leq \dots \leq [\lambda_k]$</span>. The associated tabloid to the monomial is </p><p class="math-container">\[    \begin{pmatrix}
        \lambda_1 \\
        \vdots \\
        \lambda_k
    \end{pmatrix}.\]</p><p>In this package tabloids are objects of the struct <code>Tabloid</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.Tabloid" href="#BracketAlgebras.Tabloid"><code>BracketAlgebras.Tabloid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tabloid</code></pre><p>A tabloid with ordered rows. </p><p><strong>Fields</strong></p><p>-<code>matrix::Matrix{Int}</code>: Matrix representation of the tabloid. -<code>ordering::Vector{Int}</code>: Ordering of the entries of the tabloids. <code>ordering[1]</code> &lt; <code>ordering[2]</code> &lt; ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L1-L9">source</a></section></article><p>We can associate a tabloid to a bracket algebra monomial by the tabloid corresponding to its representative.  A tabloid is said to be <em>standard</em>, iff its rows are ordered.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.standard_violation" href="#BracketAlgebras.standard_violation"><code>BracketAlgebras.standard_violation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">standard_violation(t::Tabloid)</code></pre><p>Return the index of the first violation to the standardness of the tabloid <code>t</code>, i.e. the first index where <code>t[i,j]</code> &gt; <code>t[i+1, j]</code> with regard to the ordering. Otherwise return <code>nothing</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; standard_violation(Tabloid([1 2 3; 1 4 5; 1 5 6; 2 3 4], [1,2,3,4,5,6]))
CartesianIndex(3, 2)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; standard_violation(Tabloid([1 2 3; 1 2 4], [1,2,3,4]))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L83-L98">source</a></section><section><div><pre><code class="language-julia hljs">standard_violation(b::BracketAlgebraElem)</code></pre><p>Return the index of the first standard violation of the tabloid corresponding to <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.is_standard" href="#BracketAlgebras.is_standard"><code>BracketAlgebras.is_standard</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_standard(t::Tabloid)</code></pre><p>Return whether the tabloid <code>t</code> is standard. See also <a href="#BracketAlgebras.standard_violation"><code>standard_violation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L114-L118">source</a></section><section><div><pre><code class="language-julia hljs">is_standard(b::BracketAlgebraElem)</code></pre><p>Return whether the tabloid correspondong to the bracket algebra element <code>b</code> is standard. See also <a href="#BracketAlgebras.standard_violation"><code>standard_violation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L121-L125">source</a></section></article><h2 id="The-straightening-algorithm"><a class="docs-heading-anchor" href="#The-straightening-algorithm">The straightening algorithm</a><a id="The-straightening-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-straightening-algorithm" title="Permalink"></a></h2><p>It can be shown that the straightening syziges form a Groebner basis of the Ideal <span>$I$</span> with <span>$\mathcal{B}_{n,d} \cong \mathbb{C}[\Lambda]/I$</span> with regards to the tablueax order. The result of the reduction of an element with this Groebner basis will lead to a representative, in which the tabloid corresponding to each term is standard.  This Groebner basis reduction is called the <em>straightening algorithm</em>. It can be performed by iteratively adding appropriate multiples of straightening syziges to the representative until the tabloids corresponding to all monomials in the expression are standard. Let</p><p class="math-container">\[\begin{pmatrix}
\lambda_{1,1}&amp; \dots &amp; \lambda_{1, d+1}\\
&amp;\vdots \\
\lambda_{k,1} &amp; \dots &amp; \lambda_{k, d+1}
\end{pmatrix}\]</p><p>be a non standard tabloid corresponding to a term in a bracket algebra element <span>$b$</span>.  Let <span>$(r,s)$</span> be the first index, where the tabloid is not standard, meaning <span>$\lambda_{r,s} &gt; \lambda_{r+1,s}$</span>. Let <span>$\alpha = [\lambda_{r,1}, \dots, \lambda_{r, s-1}]$</span>, <span>$\beta = [\lambda_{r, s}, \dots, \lambda_{r, d+1}, \lambda_{r+1, 1}, \dots, \lambda_{r+1, s-1}]$</span>, <span>$\gamma = [\lambda_{r+1, s}, \dots, \lambda_{r+1, d+1}]$</span>, then <span>$b = b - [\lambda_{1,1}, \dots, \lambda_{1, d+1}]\dots [\lambda_{r-1, 1}, \dots, \lambda_{r-1, d+1}] [\lambda_{r+2,1}, \dots, \lambda_{r+2, d+1}]\dots [\lambda_{k,1}, \dots, \lambda_{k, d+1}] [[\alpha\dot{\beta}\gamma]] \in \mathcal{B}_{n,d}$</span>, but the violation to the standardness occurs later in the tabloid of the adjusted term. Therefore the straightening algorithm terminates and returns a representative, where every term is standard. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.straighten" href="#BracketAlgebras.straighten"><code>BracketAlgebras.straighten</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">straighten(b::BracketAlgebraElem)</code></pre><p>Perform the straightening algorithm on the bracket algebra element <code>b</code> as in Stutrmfels 2008, Alg. 3.5.6. The straightening algorithm performs the groebner reduction of the bracket algebra element <code>b</code> with the straightening sizyges as a Groebner basis. The result is a normal form of <code>b</code> in which every term is standard. See also <a href="#BracketAlgebras.straightening_sizyge"><code>straightening_sizyge</code></a>, <a href="#BracketAlgebras.standard_violation"><code>standard_violation</code></a>, <a href="#BracketAlgebras.is_standard"><code>is_standard</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(6, 2)
Bracket algebra over P^2 on 6 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 and coefficient ring Integers.

julia&gt; b = B([1,4,5])*B([1,5,6])*B([2,3,4])
[2, 3, 4][1, 5, 6][1, 4, 5]

julia&gt; straighten(b)
[2, 5, 6][1, 4, 5][1, 3, 4] - [3, 5, 6][1, 4, 5][1, 2, 4] + [4, 5, 6][1, 4, 5][1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L168-L184">source</a></section></article><p>The straightening algorithm makes it possible to decide if two elements are equal as by basic Groebner basis results two elements of a bracket algebra are equal if and only if their representative after Groebner basis reduction (after straightening in the case of bracket algebras) are equal.</p><pre><code class="language-julia-repl hljs">julia&gt; B = BracketAlgebra(6,2)
Bracket algebra over P^2 on 6 points with point ordering 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 and coefficient ring Integers.

julia&gt; α = [1,2]
2-element Vector{Int64}:
 1
 2

julia&gt; β = [2,3,4,5]
4-element Vector{Int64}:
 2
 3
 4
 5

julia&gt; γ = Int[]
Int64[]

julia&gt; straighten(straightening_sizyge(α, β, γ, B))
0

julia&gt; straightening_sizyge(α, β, γ, B) == zero(B)
true

julia&gt; b = B([1,4,5])*B([1,5,6])*B([2,3,4])
[2, 3, 4][1, 5, 6][1, 4, 5]

julia&gt; straighten(b)
[2, 5, 6][1, 4, 5][1, 3, 4] - [3, 5, 6][1, 4, 5][1, 2, 4] + [4, 5, 6][1, 4, 5][1, 2, 3]

julia&gt; b + B([2,3,4]) * straightening_sizyge(α, β, γ, B)
[2, 3, 4][1, 5, 6][1, 4, 5] - [2, 3, 4]^2[1, 2, 5] + [2, 3, 5][2, 3, 4][1, 2, 4] - [2, 4, 5][2, 3, 4][1, 2, 3]

julia&gt; straighten(b + B([2,3,4]) * straightening_sizyge(α, β, γ, B))
[2, 5, 6][1, 4, 5][1, 3, 4] - [3, 5, 6][1, 4, 5][1, 2, 4] + [4, 5, 6][1, 4, 5][1, 2, 3]

julia&gt; b == b + B([2,3,4]) * straightening_sizyge(α, β, γ, B)
true</code></pre><h1 id="Atomic-extensors"><a class="docs-heading-anchor" href="#Atomic-extensors">Atomic extensors</a><a id="Atomic-extensors-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-extensors" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BracketAlgebras.atomic_extensors" href="#BracketAlgebras.atomic_extensors"><code>BracketAlgebras.atomic_extensors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">atomic_extensors(b::BracketAlgebraElem)</code></pre><p>Find all atomic extensors of the bracket algebra elem <code>b</code>. These are the equivalence classes of the relation p1 ~ p2 iff substituting p1 = p2 in <code>b</code> results in the zero element of the parent bracket algebra.</p><p><strong>Examples</strong></p><p>```jldoctest</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Saschobolt/BracketAlgebras.jl/blob/7b4f546811a1f2cc8e06a8ba21010736f19b6ea1/src/straightening.jl#L205-L213">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 1 April 2025 09:14">Tuesday 1 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
